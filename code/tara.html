<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tara Yantra Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    

<script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        body {
            /* Deep blue-black background for neon theme */
            background-color: #000010; 
            background: radial-gradient(circle, #000025 0%, #000005 100%);
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #333;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            /* Subtle glow for the canvas itself */
            box-shadow: 0 0 50px rgba(0, 50, 200, 0.1);
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            pointer-events: none; 
        }
        .controls button {
            pointer-events: auto;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <canvas id="yantraCanvas"></canvas>

    <div class="controls">
        <button onclick="toggleAnimation()" class="bg-red-700 hover:bg-red-500 text-red-100 font-bold py-2 px-4 rounded border border-red-500 shadow-[0_0_10px_rgba(255,0,0,0.5)] transition-all">
            Toggle Pulse
        </button>
        
        <button onclick="downloadHighResImage()" class="bg-emerald-700 hover:bg-emerald-500 text-emerald-100 font-bold py-2 px-4 rounded border border-emerald-500 shadow-[0_0_10px_rgba(0,255,100,0.5)] transition-all">
            Download 4K Image
        </button>

        <button id="recordButton" onclick="recordGIF()" class="bg-blue-700 hover:bg-blue-500 text-blue-100 font-bold py-2 px-4 rounded border border-blue-500 shadow-[0_0_10px_rgba(0,100,255,0.5)] transition-all">
            Record GIF (30s)
        </button>
    </div>

<script>
    const canvas = document.getElementById('yantraCanvas');
    const ctx = canvas.getContext('2d');

    let width, height, cx, cy;
    let animationId;
    let isAnimating = true;
    let isRecording = false;

    // Configuration for the Neon Tara Yantra
    const config = {
        bgGradientInner: '#000025', 
        bgGradientOuter: '#000005',
        bhupuraColor: '#ff0000', // Neon Red
        petalColor: '#0066ff',   // Neon Blue
        innerCircleColor: '#ffffff', // Neon White
        triangleColor: '#ff0000',    // Neon Red
        baseGlow: 15, // Base glow intensity
        scale: 0.8 
    };

    function resize() {
        if (isRecording) return;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cx = width / 2;
        cy = height / 2;
        if (!isAnimating) {
             const t = Date.now() / 30000; 
             const p = t % 1;
             calculateAndDraw(p);
        }
    }

    window.addEventListener('resize', resize);

    function getBhupuraPoints(size) {
        const halfSize = size / 2;
        const stemHalfWidth = size * 0.12; 
        const stemHeight = size * 0.06;    
        const capHalfWidth = size * 0.20;  
        const capHeight = size * 0.06;     

        const topSidePoints = [
            { x: -halfSize, y: -halfSize },          
            { x: -stemHalfWidth, y: -halfSize },     
            { x: -stemHalfWidth, y: -halfSize - stemHeight }, 
            { x: -capHalfWidth, y: -halfSize - stemHeight },  
            { x: -capHalfWidth, y: -halfSize - stemHeight - capHeight }, 
            { x: capHalfWidth, y: -halfSize - stemHeight - capHeight },  
            { x: capHalfWidth, y: -halfSize - stemHeight },   
            { x: stemHalfWidth, y: -halfSize - stemHeight },  
            { x: stemHalfWidth, y: -halfSize },      
            { x: halfSize, y: -halfSize }            
        ];

        const rotatePoint = (p) => ({ x: -p.y, y: p.x });
        let allPoints = [];
        allPoints = allPoints.concat(topSidePoints);
        const rightSidePoints = topSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(rightSidePoints);
        const bottomSidePoints = rightSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(bottomSidePoints);
        const leftSidePoints = bottomSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(leftSidePoints);
        return allPoints;
    }

    function drawBhupura(ctx, size) {
        ctx.beginPath();
        const points = getBhupuraPoints(size);
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
    }

    function drawPetal(ctx, r, w) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(w, -r/3, w, -r*0.8, 0, -r);
        ctx.bezierCurveTo(-w, -r*0.8, -w, -r/3, 0, 0);
        ctx.fill(); // Keep a subtle fill for petals
        ctx.stroke();
    }

    function drawFilledTriangle(ctx, radius, inverted = true) {
        ctx.beginPath();
        const dir = inverted ? 1 : -1;
        const startAngle = inverted ? (Math.PI / 2) : (-Math.PI / 2);
        for (let i = 0; i < 3; i++) {
            const angle = startAngle + (i * 2 * Math.PI / 3);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle) * dir;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill(); // Keep a subtle fill for the triangle
        ctx.stroke();
    }

    function draw(pulsePhase, petalRotation, triangleRotation) {
        // Clear and Background with radial gradient
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(width, height));
        gradient.addColorStop(0, config.bgGradientInner);
        gradient.addColorStop(1, config.bgGradientOuter);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const minDim = Math.min(canvas.width, canvas.height);
        const size = minDim * config.scale;
        const bhupuraSize = size * 0.9;
        
        // Resolution scaling for consistent glow thickness
        const resScale = minDim / 512; 

        // Sine wave for breathing.
        const sineWave = Math.sin(pulsePhase * Math.PI * 2 * 10); 
        
        // Gentle glow pulse
        const glowStrength = (config.baseGlow + (sineWave * 5)) * resScale;
        
        ctx.translate(cx, cy);

        // 1. BHUPURA (Red Neon)
        ctx.save();
        const bhupuraScale = 1 + (sineWave * 0.015); 
        ctx.scale(bhupuraScale, bhupuraScale);

        ctx.strokeStyle = config.bhupuraColor;
        ctx.lineWidth = minDim * 0.008; // Thinner lines for pure neon
        ctx.lineCap = 'square';
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 4; 
        ctx.shadowBlur = glowStrength * 1.5;
        ctx.shadowColor = config.bhupuraColor;
        
        // Draw main Bhupura outline - NO FILL
        drawBhupura(ctx, bhupuraSize);
        ctx.stroke();
        
        // Inner Bhupura line (thinner, more subtle glow) - NO FILL
        ctx.lineWidth = minDim * 0.002;
        ctx.shadowBlur = glowStrength * 0.5;
        drawBhupura(ctx, bhupuraSize * 0.93); 
        ctx.stroke();
        ctx.restore();

        // 2. PETALS (Blue Neon)
        const baseOuterRadius = bhupuraSize * 0.45;
        const petalRadius = baseOuterRadius;
        const petalWidth = petalRadius * 0.4;
        
        ctx.shadowBlur = glowStrength * 0.8;
        ctx.shadowColor = config.petalColor;
        
        ctx.save();
        ctx.rotate(-petalRotation); 

        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate((i * Math.PI / 4));
            ctx.translate(0, -baseOuterRadius * 0.1); // Offset petals
            
            // Petals have a very subtle, almost transparent blue fill + glowing stroke
            ctx.fillStyle = config.petalColor + '10'; // Very transparent blue fill
            ctx.lineWidth = minDim * 0.005;
            ctx.strokeStyle = config.petalColor;
            
            drawPetal(ctx, petalRadius, petalWidth);
            ctx.restore();
        }
        ctx.restore(); 

        // 3. INNER CIRCLE (White Neon)
        const circleRadius = baseOuterRadius * 0.75;
        ctx.strokeStyle = config.innerCircleColor;
        ctx.lineWidth = minDim * 0.008; // Thicker white ring
        ctx.shadowColor = config.innerCircleColor;
        ctx.shadowBlur = glowStrength * 1.2;
        
        ctx.beginPath();
        ctx.arc(0, 0, circleRadius, 0, Math.PI * 2);
        // Inner circle has no fill, only glowing stroke
        ctx.stroke();

        // 4. CENTRAL TRIANGLE (Red Neon)
        ctx.save();
        ctx.rotate(triangleRotation);
        
        const triScale = 1 + sineWave * 0.03; // Gentle bounce for triangle
        ctx.scale(triScale, triScale);

        const triangleRadius = circleRadius * 0.85; // Slightly smaller to fit inside
        
        ctx.fillStyle = config.triangleColor + '30'; // Semi-transparent red fill
        ctx.strokeStyle = config.triangleColor;
        ctx.lineWidth = minDim * 0.008; // Thicker lines for neon
        ctx.shadowColor = config.triangleColor;
        ctx.shadowBlur = glowStrength * 1.5;
        
        drawFilledTriangle(ctx, triangleRadius, true); // Inverted
        
        ctx.restore();

        ctx.translate(-cx, -cy);
    }

    function calculateAndDraw(progress) {
        const pulsePhase = progress;
        // Petals rotate 1/8th of circle (45 deg) per loop.
        const petalRot = progress * (Math.PI / 4); 
        // Triangle rotates 1/3rd (120 deg) for symmetry.
        const triangleRot = progress * (2 * Math.PI / 3);

        draw(pulsePhase, petalRot, triangleRot);
    }

    function animate() {
        if (isRecording) return;

        if (isAnimating) {
            const period = 30000; 
            const t = Date.now() % period;
            const progress = t / period;
            calculateAndDraw(progress);
        }
        animationId = requestAnimationFrame(animate);
    }

    function toggleAnimation() {
        isAnimating = !isAnimating;
    }

    async function getWorkerBlob() {
        try {
            const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
            if (!response.ok) throw new Error('Network response was not ok');
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        } catch (e) {
            console.error("Could not load worker script:", e);
            alert("Error loading GIF worker script.");
            return null;
        }
    }

    function downloadHighResImage() {
        const oldWidth = canvas.width;
        const oldHeight = canvas.height;
        const oldCx = cx;
        const oldCy = cy;

        const RES = 3000;
        canvas.width = RES;
        canvas.height = RES;
        cx = RES / 2;
        cy = RES / 2;

        const staticProgress = 0.0; 
        calculateAndDraw(staticProgress);

        const link = document.createElement('a');
        link.download = 'tara_yantra_4k.png'; 
        link.href = canvas.toDataURL('image/png');
        link.click();

        canvas.width = oldWidth;
        canvas.height = oldHeight;
        cx = oldCx;
        cy = oldCy;
        
        if(!isAnimating) {
             const t = Date.now() / 30000; 
             const p = t % 1;
             calculateAndDraw(p);
        }
    }

    async function recordGIF() {
        if (isRecording) return;
        
        const recordButton = document.getElementById('recordButton');
        const originalText = recordButton.textContent;
        
        recordButton.disabled = true;
        recordButton.textContent = 'Loading...';

        const workerScript = await getWorkerBlob();
        if (!workerScript) {
            recordButton.disabled = false;
            recordButton.textContent = originalText;
            return;
        }

        isRecording = true;
        cancelAnimationFrame(animationId);

        recordButton.textContent = 'Recording (30s)...';

        const SIZE = 720; 

        const gif = new GIF({
            workers: 2,
            quality: 10,
            width: SIZE,
            height: SIZE,
            workerScript: workerScript
        });

        const oldWidth = canvas.width;
        const oldHeight = canvas.height;
        const oldCx = cx;
        const oldCy = cy;

        canvas.width = SIZE;
        canvas.height = SIZE;
        cx = SIZE / 2;
        cy = SIZE / 2;

        const duration = 30000; 
        const frameDelay = 66; 
        const totalFrames = Math.floor(duration / frameDelay);

        for (let i = 0; i < totalFrames; i++) {
            const progress = i / totalFrames;
            calculateAndDraw(progress);
            gif.addFrame(ctx, {copy: true, delay: frameDelay});
        }

        recordButton.textContent = 'Rendering 0%...';
        
        gif.on('progress', function(p) {
             recordButton.textContent = `Rendering ${Math.round(p * 100)}%...`;
        });
        
        gif.on('finished', function(blob) {
            canvas.width = oldWidth;
            canvas.height = oldHeight;
            cx = oldCx;
            cy = oldCy;
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tara_yantra_loop_hd.gif'; 
            a.click();
            URL.revokeObjectURL(url);

            isRecording = false;
            recordButton.disabled = false;
            recordButton.textContent = originalText;
            animate(); 
        });

        gif.render();
    }

    resize();
    animate();

</script>
</body>
</html>
