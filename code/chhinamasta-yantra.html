<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinnamasta Yantra Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        body {
            /* Deep Electric Purple/Black Background for Thunder Theme */
            background-color: #0a000f; 
            background: radial-gradient(circle, #1a0520 0%, #000000 100%);
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #333;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            box-shadow: 0 0 60px rgba(255, 255, 0, 0.15);
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            pointer-events: none;
        }
        .controls button {
            pointer-events: auto;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <canvas id="yantraCanvas"></canvas>

    <div class="controls">
        <button onclick="toggleAnimation()" class="bg-yellow-900 hover:bg-yellow-700 text-yellow-100 font-bold py-2 px-4 rounded border border-yellow-500 shadow-[0_0_10px_rgba(255,255,0,0.5)] transition-all">
            Toggle Pulse
        </button>
        
        <button onclick="downloadHighResImage()" class="bg-purple-900 hover:bg-purple-700 text-purple-100 font-bold py-2 px-4 rounded border border-purple-500 shadow-[0_0_10px_rgba(147,112,219,0.5)] transition-all">
            Download 4K Image
        </button>

        <button id="recordButton" onclick="recordGIF()" class="bg-red-900 hover:bg-red-700 text-red-100 font-bold py-2 px-4 rounded border border-red-500 shadow-[0_0_10px_rgba(255,0,0,0.5)] transition-all">
            Record GIF (30s)
        </button>
    </div>

<script>
    const canvas = document.getElementById('yantraCanvas');
    const ctx = canvas.getContext('2d');

    let width, height, cx, cy;
    let animationId;
    let isAnimating = true;
    let isRecording = false;

    // Configuration for Chinnamasta Yantra (Neon Thunder Theme)
    const config = {
        bgGradientInner: '#1a0520', 
        bgGradientOuter: '#000000',
        bhupuraColor: '#FFFF00',    // Neon Yellow (Lightning)
        petalColor: '#FF0000',      // Neon Red (Life Force)
        triangleOuterColor: '#FFFFFF', // Neon White (Bone/Lightning)
        circleColor: '#FF4500',     // Neon Orange Red
        triangleInnerColor: '#FFFF00', // Neon Yellow
        binduColor: '#FF0000',      // Red
        baseGlow: 15,
        scale: 0.8
    };

    function resize() {
        if (isRecording) return;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cx = width / 2;
        cy = height / 2;
        if (!isAnimating) {
             const t = Date.now() / 30000; 
             const p = t % 1;
             calculateAndDraw(p);
        }
    }

    window.addEventListener('resize', resize);

    // --- Geometry Helpers ---

    function getBhupuraPoints(size) {
        const halfSize = size / 2;
        const stemHalfWidth = size * 0.12;
        const stemHeight = size * 0.06;
        const capHalfWidth = size * 0.20;
        const capHeight = size * 0.06;

        const topSidePoints = [
            { x: -halfSize, y: -halfSize },
            { x: -stemHalfWidth, y: -halfSize },
            { x: -stemHalfWidth, y: -halfSize - stemHeight },
            { x: -capHalfWidth, y: -halfSize - stemHeight },
            { x: -capHalfWidth, y: -halfSize - stemHeight - capHeight },
            { x: capHalfWidth, y: -halfSize - stemHeight - capHeight },
            { x: capHalfWidth, y: -halfSize - stemHeight },
            { x: stemHalfWidth, y: -halfSize - stemHeight },
            { x: stemHalfWidth, y: -halfSize },
            { x: halfSize, y: -halfSize }
        ];

        const rotatePoint = (p) => ({ x: -p.y, y: p.x });
        let allPoints = [];
        allPoints = allPoints.concat(topSidePoints);
        const rightSidePoints = topSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(rightSidePoints);
        const bottomSidePoints = rightSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(bottomSidePoints);
        const leftSidePoints = bottomSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(leftSidePoints);
        return allPoints;
    }

    function drawBhupura(ctx, size) {
        ctx.beginPath();
        const points = getBhupuraPoints(size);
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.stroke();
    }

    function drawPetal(ctx, r, w) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(w, -r/3, w, -r*0.8, 0, -r);
        ctx.bezierCurveTo(-w, -r*0.8, -w, -r/3, 0, 0);
        ctx.stroke();
    }

    function drawTriangle(ctx, r, inverted = true) {
        ctx.beginPath();
        const dir = inverted ? 1 : -1;
        const startAngle = inverted ? (Math.PI / 2) : (-Math.PI / 2);
        for (let i = 0; i < 3; i++) {
            const angle = startAngle + (i * 2 * Math.PI / 3);
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle) * dir;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
    }

    // --- Main Draw Function ---

    function draw(pulsePhase, rotationPhase) {
        // Background
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(width, height));
        gradient.addColorStop(0, config.bgGradientInner);
        gradient.addColorStop(1, config.bgGradientOuter);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const minDim = Math.min(canvas.width, canvas.height);
        const size = minDim * config.scale;
        const bhupuraSize = size * 0.9;
        
        const resScale = minDim / 512; 

        // Sharper Pulse for "Thunder" effect
        // Using a slightly sharper sine wave
        const rawSine = Math.sin(pulsePhase * Math.PI * 2 * 10);
        const sineWave = rawSine * rawSine * rawSine; // Make it peakier
        const glowStrength = (config.baseGlow + (sineWave * 5)) * resScale;
        
        ctx.translate(cx, cy);

        // 1. BHUPURA (Neon Yellow - Lightning)
        ctx.save();
        const bhupuraScale = 1 + (sineWave * 0.01); 
        ctx.scale(bhupuraScale, bhupuraScale);

        ctx.strokeStyle = config.bhupuraColor;
        ctx.lineWidth = minDim * 0.008; 
        ctx.lineCap = 'square';
        ctx.lineJoin = 'miter';
        ctx.shadowBlur = glowStrength * 1.5;
        ctx.shadowColor = config.bhupuraColor;
        
        drawBhupura(ctx, bhupuraSize);
        ctx.stroke();
        
        ctx.lineWidth = minDim * 0.002;
        ctx.shadowBlur = glowStrength * 0.5;
        drawBhupura(ctx, bhupuraSize * 0.93); 
        ctx.stroke();
        ctx.restore();

        // 2. LOTUS (8 Petals - Neon Red)
        const baseOuterRadius = bhupuraSize * 0.45;
        const petalRadius = baseOuterRadius;
        const petalWidth = petalRadius * 0.4;
        
        ctx.shadowBlur = glowStrength * 0.8;
        ctx.shadowColor = config.petalColor;
        
        ctx.save();
        ctx.rotate(rotationPhase); 

        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate((i * Math.PI / 4));
            ctx.translate(0, -baseOuterRadius * 0.1);
            
            // Subtle fill
            ctx.fillStyle = config.petalColor + '15'; 
            ctx.strokeStyle = config.petalColor;
            ctx.lineWidth = minDim * 0.005;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(petalWidth, -petalRadius/3, petalWidth, -petalRadius*0.8, 0, -petalRadius);
            ctx.bezierCurveTo(-petalWidth, -petalRadius*0.8, -petalWidth, -petalRadius/3, 0, 0);
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }
        ctx.restore(); 

        // 3. OUTER TRIANGLE (White/Silver)
        const triRadius = baseOuterRadius * 0.8;
        ctx.save();
        const bounce = 1 + sineWave * 0.02;
        ctx.scale(bounce, bounce);
        
        // Rotate slowly counter-clockwise
        ctx.rotate(-rotationPhase * 0.5);

        ctx.strokeStyle = config.triangleOuterColor;
        ctx.lineWidth = minDim * 0.010;
        ctx.shadowColor = config.triangleOuterColor;
        ctx.shadowBlur = glowStrength * 1.5;
        
        drawTriangle(ctx, triRadius, true); // Inverted

        // 4. INNER CIRCLE (Orange/Red)
        const innerCircleRadius = triRadius * 0.5;
        ctx.strokeStyle = config.circleColor;
        ctx.lineWidth = minDim * 0.005;
        ctx.shadowColor = config.circleColor;
        ctx.shadowBlur = glowStrength;
        
        ctx.beginPath();
        ctx.arc(0, 0, innerCircleRadius, 0, Math.PI * 2);
        ctx.stroke();

        // 5. INNER TRIANGLE (Yellow)
        const innerTriRadius = innerCircleRadius * 0.9;
        ctx.save();
        // Rotate clockwise relative to container
        ctx.rotate(rotationPhase * 1.0); 
        
        ctx.strokeStyle = config.triangleInnerColor;
        ctx.lineWidth = minDim * 0.006;
        ctx.shadowColor = config.triangleInnerColor;
        
        drawTriangle(ctx, innerTriRadius, true); // Inverted

        ctx.restore(); // Restore rotation for inner triangle

        ctx.restore(); // Restore bounce and outer triangle rotation

        // 6. BINDU (Red)
        ctx.beginPath();
        ctx.arc(0, 0, minDim * 0.015, 0, Math.PI * 2);
        ctx.fillStyle = config.binduColor;
        ctx.shadowColor = config.binduColor;
        ctx.shadowBlur = glowStrength * 2.0;
        ctx.fill();

        ctx.translate(-cx, -cy);
    }

    function calculateAndDraw(progress) {
        const pulsePhase = progress;
        const rotationPhase = progress * (Math.PI / 4); 
        
        draw(pulsePhase, rotationPhase);
    }

    function animate() {
        if (isRecording) return;
        if (isAnimating) {
            const period = 30000; 
            const t = Date.now() % period;
            const progress = t / period;
            calculateAndDraw(progress);
        }
        animationId = requestAnimationFrame(animate);
    }

    function toggleAnimation() {
        isAnimating = !isAnimating;
    }

    async function getWorkerBlob() {
        try {
            const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
            if (!response.ok) throw new Error('Network response was not ok');
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        } catch (e) {
            console.error("Could not load worker script:", e);
            alert("Error loading GIF worker script.");
            return null;
        }
    }

    function downloadHighResImage() {
        const oldWidth = canvas.width;
        const oldHeight = canvas.height;
        const oldCx = cx;
        const oldCy = cy;

        const RES = 3000;
        canvas.width = RES;
        canvas.height = RES;
        cx = RES / 2;
        cy = RES / 2;

        calculateAndDraw(0.1); 

        const link = document.createElement('a');
        link.download = 'chinnamasta_yantra_4k.png'; 
        link.href = canvas.toDataURL('image/png');
        link.click();

        canvas.width = oldWidth;
        canvas.height = oldHeight;
        cx = oldCx;
        cy = oldCy;
        
        if(!isAnimating) {
             calculateAndDraw(Date.now() / 30000 % 1);
        }
    }

    async function recordGIF() {
        if (isRecording) return;
        
        const recordButton = document.getElementById('recordButton');
        const originalText = recordButton.textContent;
        
        recordButton.disabled = true;
        recordButton.textContent = 'Loading...';

        const workerScript = await getWorkerBlob();
        if (!workerScript) {
            recordButton.disabled = false;
            recordButton.textContent = originalText;
            return;
        }

        isRecording = true;
        cancelAnimationFrame(animationId);

        recordButton.textContent = 'Recording (30s)...';

        const SIZE = 720; 

        const gif = new GIF({
            workers: 2,
            quality: 10,
            width: SIZE,
            height: SIZE,
            workerScript: workerScript
        });

        const oldWidth = canvas.width;
        const oldHeight = canvas.height;
        const oldCx = cx;
        const oldCy = cy;

        canvas.width = SIZE;
        canvas.height = SIZE;
        cx = SIZE / 2;
        cy = SIZE / 2;

        const duration = 30000; 
        const frameDelay = 66; 
        const totalFrames = Math.floor(duration / frameDelay);

        for (let i = 0; i < totalFrames; i++) {
            const progress = i / totalFrames;
            calculateAndDraw(progress);
            gif.addFrame(ctx, {copy: true, delay: frameDelay});
        }

        recordButton.textContent = 'Rendering 0%...';
        
        gif.on('progress', function(p) {
             recordButton.textContent = `Rendering ${Math.round(p * 100)}%...`;
        });
        
        gif.on('finished', function(blob) {
            canvas.width = oldWidth;
            canvas.height = oldHeight;
            cx = oldCx;
            cy = oldCy;
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'chinnamasta_yantra_loop_hd.gif'; 
            a.click();
            URL.revokeObjectURL(url);

            isRecording = false;
            recordButton.disabled = false;
            recordButton.textContent = originalText;
            animate(); 
        });

        gif.render();
    }

    resize();
    animate();

</script>
</body>
</html>
