<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kali Yantra Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Library for recording GIFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        body {
            background-color: #050000;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #333;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.1);
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            pointer-events: none; /* Let clicks pass through container */
        }
        .controls button {
            pointer-events: auto; /* Re-enable clicks on buttons */
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <canvas id="yantraCanvas"></canvas>

    <div class="controls">
        <button onclick="toggleAnimation()" class="bg-red-900 hover:bg-red-700 text-red-100 font-bold py-2 px-4 rounded border border-red-500 shadow-[0_0_10px_rgba(255,0,0,0.5)] transition-all">
            Toggle Pulse
        </button>
        
        <button onclick="downloadHighResImage()" class="bg-emerald-900 hover:bg-emerald-700 text-emerald-100 font-bold py-2 px-4 rounded border border-emerald-500 shadow-[0_0_10px_rgba(0,255,100,0.5)] transition-all">
            Download 4K Image
        </button>

        <button id="recordButton" onclick="recordGIF()" class="bg-blue-900 hover:bg-blue-700 text-blue-100 font-bold py-2 px-4 rounded border border-blue-500 shadow-[0_0_10px_rgba(0,100,255,0.5)] transition-all">
            Record GIF (30s)
        </button>
    </div>

<script>
    const canvas = document.getElementById('yantraCanvas');
    const ctx = canvas.getContext('2d');

    let width, height, cx, cy;
    let animationId;
    let isAnimating = true;
    let isRecording = false;

    // Configuration for the Yantra geometry
    const config = {
        bgGradientInner: '#300000',
        bgGradientOuter: '#000000',
        redColor: '#ff0000',
        whiteColor: '#ffffff',
        baseGlow: 15,
        scale: 0.75 
    };

    function resize() {
        if (isRecording) return;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cx = width / 2;
        cy = height / 2;
        // Trigger a single draw frame if not animating
        if (!isAnimating) {
             const t = Date.now() / 30000; 
             const p = t % 1;
             calculateAndDraw(p);
        }
    }

    window.addEventListener('resize', resize);

    function getBhupuraPoints(size) {
        const halfSize = size / 2;
        const stemHalfWidth = size * 0.12; 
        const stemHeight = size * 0.06;    
        const capHalfWidth = size * 0.20;  
        const capHeight = size * 0.06;     

        const topSidePoints = [
            { x: -halfSize, y: -halfSize },          
            { x: -stemHalfWidth, y: -halfSize },     
            { x: -stemHalfWidth, y: -halfSize - stemHeight }, 
            { x: -capHalfWidth, y: -halfSize - stemHeight },  
            { x: -capHalfWidth, y: -halfSize - stemHeight - capHeight }, 
            { x: capHalfWidth, y: -halfSize - stemHeight - capHeight },  
            { x: capHalfWidth, y: -halfSize - stemHeight },   
            { x: stemHalfWidth, y: -halfSize - stemHeight },  
            { x: stemHalfWidth, y: -halfSize },      
            { x: halfSize, y: -halfSize }            
        ];

        const rotatePoint = (p) => ({ x: -p.y, y: p.x });
        let allPoints = [];
        allPoints = allPoints.concat(topSidePoints);
        const rightSidePoints = topSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(rightSidePoints);
        const bottomSidePoints = rightSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(bottomSidePoints);
        const leftSidePoints = bottomSidePoints.map(rotatePoint);
        allPoints = allPoints.concat(leftSidePoints);
        return allPoints;
    }

    function drawBhupura(ctx, size) {
        const points = getBhupuraPoints(size);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
    }

    function drawPetal(ctx, r, w) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(w, -r/3, w, -r*0.8, 0, -r);
        ctx.bezierCurveTo(-w, -r*0.8, -w, -r/3, 0, 0);
        ctx.fill();
    }

    function drawFilledTriangle(ctx, radius, inverted = true) {
        ctx.beginPath();
        const dir = inverted ? 1 : -1;
        for (let i = 0; i < 3; i++) {
            const angle = (Math.PI / 2) + (i * 2 * Math.PI / 3);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle) * dir;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    /**
     * Main Draw Function
     * @param {number} pulsePhase - 0 to 1 value for the breathing cycle
     * @param {number} petalRotation - Radians to rotate the petal ring
     * @param {number} triangleRotation - Radians to rotate the inner triangle
     */
    function draw(pulsePhase, petalRotation, triangleRotation) {
        // Clear and Background
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(width, height));
        gradient.addColorStop(0, config.bgGradientInner);
        gradient.addColorStop(1, config.bgGradientOuter);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const minDim = Math.min(canvas.width, canvas.height);
        const size = minDim * config.scale;
        const bhupuraSize = size * 0.8;
        
        // Resolution scaling for consistent glow thickness
        const resScale = minDim / 512; 

        // Sine wave for breathing.
        // Cycle is 30s. We want a breath every 3s -> 10 cycles.
        const sineWave = Math.sin(pulsePhase * Math.PI * 2 * 10); 
        
        // Gentle glow pulse
        const glowStrength = (config.baseGlow + (sineWave * 5)) * resScale;
        
        ctx.translate(cx, cy);

        // 1. BHUPURA (Square)
        ctx.save();
        // Pulse size slightly
        const bhupuraScale = 1 + (sineWave * 0.015); 
        ctx.scale(bhupuraScale, bhupuraScale);

        ctx.strokeStyle = config.redColor;
        ctx.lineWidth = minDim * 0.015;
        ctx.lineCap = 'square';
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 4; 
        ctx.shadowBlur = glowStrength * 1.5;
        ctx.shadowColor = config.redColor;
        
        drawBhupura(ctx, bhupuraSize);
        ctx.stroke();
        
        ctx.lineWidth = minDim * 0.003;
        ctx.shadowBlur = glowStrength * 0.5;
        drawBhupura(ctx, bhupuraSize * 0.93); 
        ctx.stroke();
        ctx.restore();

        // 2. OUTER CIRCLE
        const baseOuterRadius = bhupuraSize * 0.38;
        const ringSpacing = minDim * 0.012; 
        ctx.strokeStyle = config.whiteColor;
        ctx.lineWidth = minDim * 0.005;
        ctx.shadowColor = config.whiteColor;
        ctx.shadowBlur = glowStrength;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(0, 0, baseOuterRadius + (i * ringSpacing), 0, Math.PI * 2);
            ctx.stroke();
        }

        // 3. LOTUS PETALS
        const petalRadius = baseOuterRadius * 0.95;
        const petalWidth = petalRadius * 0.35;
        
        ctx.shadowBlur = glowStrength * 0.5;
        ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
        
        ctx.save();
        // Rotate the entire petal ring
        ctx.rotate(-petalRotation); 

        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate((i * Math.PI / 4));
            ctx.translate(0, -baseOuterRadius * 0.05);
            
            const pGrad = ctx.createLinearGradient(0, 0, 0, -petalRadius);
            pGrad.addColorStop(0, '#200000');
            pGrad.addColorStop(0.5, '#500000');
            pGrad.addColorStop(1, '#100000');
            
            ctx.fillStyle = pGrad;
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ff3333';
            
            drawPetal(ctx, petalRadius, petalWidth);
            ctx.restore();
        }
        ctx.restore(); 

        // 4. INNER CIRCLE
        const baseInnerRadius = petalRadius * 0.65;
        ctx.strokeStyle = config.redColor;
        ctx.lineWidth = minDim * 0.005;
        ctx.shadowColor = config.redColor;
        ctx.shadowBlur = glowStrength * 1.2;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(0, 0, baseInnerRadius - (i * ringSpacing), 0, Math.PI * 2);
            ctx.stroke();
        }

        // 5. TRIANGLES
        ctx.save();
        ctx.rotate(triangleRotation);

        // Bounce effect (matches breath rhythm)
        const bounce = 1 + sineWave * 0.03;
        ctx.scale(bounce, bounce);

        const innermostRingRadius = baseInnerRadius - (2 * ringSpacing);
        const t1Radius = innermostRingRadius * 0.90; 
        
        ctx.strokeStyle = config.whiteColor;
        ctx.lineWidth = minDim * 0.006;
        ctx.shadowColor = config.whiteColor;
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; 
        drawFilledTriangle(ctx, t1Radius, true);

        const t2Radius = t1Radius * 0.7;
        ctx.strokeStyle = config.redColor;
        ctx.lineWidth = minDim * 0.006;
        ctx.shadowColor = config.redColor;
        drawFilledTriangle(ctx, t2Radius, true);

        const t3Radius = t2Radius * 0.65;
        ctx.strokeStyle = config.whiteColor;
        ctx.lineWidth = minDim * 0.005;
        ctx.shadowColor = config.whiteColor;
        drawFilledTriangle(ctx, t3Radius, true);
        
        const t4Radius = t3Radius * 0.55;
        ctx.strokeStyle = config.redColor;
        ctx.lineWidth = minDim * 0.004;
        ctx.shadowColor = config.redColor;
        drawFilledTriangle(ctx, t4Radius, true);

        // 6. BINDU
        ctx.beginPath();
        ctx.arc(0, 0, minDim * 0.008, 0, Math.PI * 2);
        ctx.fillStyle = config.redColor;
        ctx.shadowColor = config.redColor;
        ctx.shadowBlur = glowStrength * 2;
        ctx.fill();
        
        ctx.restore();

        ctx.translate(-cx, -cy);
    }

    // Central logic to calculate animation state based on progress (0 to 1)
    function calculateAndDraw(progress) {
        // 1. Pulse: 0 to 1
        const pulsePhase = progress;

        // 2. Petals: 8-fold symmetry. Rotate 1/8th of circle (45 deg) per loop.
        // This ensures Petal 1 ends up exactly where Petal 2 started.
        const petalRot = progress * (Math.PI / 4); 

        // 3. Triangles: 3-fold symmetry. Rotate 1/3rd of circle (120 deg) per loop.
        // This ensures Triangle ends up exactly matching its start shape.
        const triangleRot = progress * (2 * Math.PI / 3);

        draw(pulsePhase, petalRot, triangleRot);
    }

    function animate() {
        if (isRecording) return;

        if (isAnimating) {
            // 30 second loop period for live view
            const period = 30000; 
            const t = Date.now() % period;
            const progress = t / period;
            calculateAndDraw(progress);
        }
        animationId = requestAnimationFrame(animate);
    }

    function toggleAnimation() {
        isAnimating = !isAnimating;
    }

    async function getWorkerBlob() {
        try {
            const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
            if (!response.ok) throw new Error('Network response was not ok');
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        } catch (e) {
            console.error("Could not load worker script:", e);
            alert("Error loading GIF worker script. Please check your internet connection.");
            return null;
        }
    }

    function downloadHighResImage() {
        // Save current state
        const oldWidth = canvas.width;
        const oldHeight = canvas.height;
        const oldCx = cx;
        const oldCy = cy;

        // Set to 4K Resolution
        const RES = 3000;
        canvas.width = RES;
        canvas.height = RES;
        cx = RES / 2;
        cy = RES / 2;

        // Draw Current Frame at high res
        // Calculate a fixed nice frame (e.g., 10% into animation) so it looks good
        const staticProgress = 0.1; 
        calculateAndDraw(staticProgress);

        // Create Link
        const link = document.createElement('a');
        link.download = 'kali_yantra_4k.png';
        link.href = canvas.toDataURL('image/png');
        link.click();

        // Restore
        canvas.width = oldWidth;
        canvas.height = oldHeight;
        cx = oldCx;
        cy = oldCy;
        
        // Redraw current frame for user
        if(!isAnimating) {
             const t = Date.now() / 30000; 
             const p = t % 1;
             calculateAndDraw(p);
        }
    }

    async function recordGIF() {
        if (isRecording) return;
        
        const recordButton = document.getElementById('recordButton');
        const originalText = recordButton.textContent;
        
        recordButton.disabled = true;
        recordButton.textContent = 'Loading...';

        const workerScript = await getWorkerBlob();
        if (!workerScript) {
            recordButton.disabled = false;
            recordButton.textContent = originalText;
            return;
        }

        isRecording = true;
        cancelAnimationFrame(animationId);

        recordButton.textContent = 'Recording (30s)...';

        // Optimized GIF size for browser stability. 
        // 720x720 is good HD balance for 30s. 3000px would crash.
        const SIZE = 720; 

        const gif = new GIF({
            workers: 2,
            quality: 10,
            width: SIZE,
            height: SIZE,
            workerScript: workerScript
        });

        // Store old state
        const oldWidth = canvas.width;
        const oldHeight = canvas.height;
        const oldCx = cx;
        const oldCy = cy;

        // Setup for Record
        canvas.width = SIZE;
        canvas.height = SIZE;
        cx = SIZE / 2;
        cy = SIZE / 2;

        // 30 Seconds @ 15 FPS
        const duration = 30000; 
        const frameDelay = 66; 
        const totalFrames = Math.floor(duration / frameDelay);

        for (let i = 0; i < totalFrames; i++) {
            const progress = i / totalFrames;
            calculateAndDraw(progress);
            gif.addFrame(ctx, {copy: true, delay: frameDelay});
        }

        recordButton.textContent = 'Rendering 0%...';
        
        gif.on('progress', function(p) {
             recordButton.textContent = `Rendering ${Math.round(p * 100)}%...`;
        });
        
        gif.on('finished', function(blob) {
            // Restore
            canvas.width = oldWidth;
            canvas.height = oldHeight;
            cx = oldCx;
            cy = oldCy;
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'kali_yantra_loop_hd.gif';
            a.click();
            URL.revokeObjectURL(url);

            isRecording = false;
            recordButton.disabled = false;
            recordButton.textContent = originalText;
            animate(); 
        });

        gif.render();
    }

    resize();
    animate();

</script>
</body>
</html>
